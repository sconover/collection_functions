bang methods do work in place
  you need in-place editing capability to do things in place
    append is an example of in-place editing
      same with comparable
        once this feature is available, attempt to determine whether a 
          collection is sorted before intersect, uniq, differ, etc
            ...test-drive using cost


cost should really be counted by # of next's, not in 'each'

declare features to function mappings up front?
  then only return what's available to use...
  also more performant...feature functions are resolved early.
  need to do this such that it's not developer-error-prone.
    hmm...just determine this when doing function mapping at the bottom?
      default function..."BUG: Feature not available, this operation should not have been exposed."
    
implementations by feature...
  size: efficient size function
  ["size"]
  ["size", "sort"]
  feature.size && feature.sort
  ...these are determined once, up-front
  

would be neat if you could dictate space- or time-efficient

tests for array and some canonical non-array

named-param style
  defaults?

accumulated cost makes things ugly.  what to do?

things that should be configurable:
  - what gets returned when there's no match
  - signal for breaking out of a loop
  
  - function names...
  
...just yield the functions, k-v style, and allow the caller to decide what to do...

later: good errors for when you don't define a feature.
  checkFeatures() ?