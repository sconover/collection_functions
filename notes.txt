bang methods do work in place
  you need in-place editing capability to do things in place
    append is an example of in-place editing
    need other features like remove and insert
      even more reason to have some sort of rf'd feature checking capability...
      feature("append")()
      capability("append")(collection, item)
      capability("new")()
        insert, remove, concat, etc
      contained in methods that fall back to other features?
        concat -> new + append, append, append
        length -> each(...count...)
        test-drive using cost
      same with comparable
        once this feature is available, attempt to determine whether a 
          collection is sorted before intersect, uniq, differ, etc
            ...test-drive using cost


implementations by feature...
  size: efficient size function
  ["size"]
  ["size", "sort"]
  feature.size && feature.sort
  ...these are determined once, up-front
  

would be neat if you could dictate space- or time-efficient

tests for array and some canonical non-array

named-param style
  defaults?

accumulated cost makes things ugly.  what to do?

things that should be configurable:
  - what gets returned when there's no match
  - signal for breaking out of a loop
  
  - function names...
  
...just yield the functions, k-v style, and allow the caller to decide what to do...

later: good errors for when you don't define a feature.
  checkFeatures() ?